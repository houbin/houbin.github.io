title: java使用jni调用c++的so
date: 2016-04-04 09:17:55
tags: 
  - java 
  - jni 
  - c++ 
  - so
categories: ceph
---

在学习hadoop中集成ceph作为文件系统存储时，发现hadoop是通过如下调用过程来完成对ceph的使用。

hadoop-ceph.jar  ->  libcephfs.jar  ->  libcephfs_jni.so  ->  libcephfs.so

在此过程中，用到了JNI这种允许java直接调用so的技术，特学习并分享出来。

<!-- more -->

## 准备工作
- 安装jdk
- gcc编译环境

## java调用方

java端测试程序代码如下:

``` ```
package com.houbin.jni;

public class Hello
{
    static
    {
        try
        {
            System.loadLibrary("hello");
        }
        catch (UnsatisfiedLinkError e)
        {
            System.err.println("cannot load library: \n" + e.toString());
        }
    }

    public native static void native_say_hello(String strName);

    public static void SayHello(String name)
    {
        native_say_hello(name);
    }

    public static void main(String args[])
    {
        System.out.println(System.getProperty("java.library.path"));
        SayHello("123456");
    }
}
```

其中，java需要so中的方法使用native来标识，这个示例程序中只需要一个so的方法如下：

public native static void native_say_hello(String strName);

### 编译java代码
``` powershell
[root@pc jni]# javac -d . Hello.java
```
该命令会在当前目录生成对应的目录和class文件

``` powershell
[root@pc jni]# tree
.
├── com
│   └── houbin
│       └── jni
│           └── Hello.class
```

### 生成头文件

``` powershell
[root@pc jni]# javah com.houbin.jni.Hello
```
该命令会生成对应的头文件，该头文件用于标明c++代码中需要实现的方法
``` powershell
[root@pc jni]# ll
total 32
drwxr-xr-x 3 root root 4096 Apr  4 09:25 com
-rw-r--r-- 1 root root  477 Apr  4 09:26 com_houbin_jni_Hello.h

[root@pc jni]# cat com_houbin_jni_Hello.h
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_houbin_jni_Hello */

#ifndef _Included_com_houbin_jni_Hello
#define _Included_com_houbin_jni_Hello
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_houbin_jni_Hello
 * Method:    native_say_hello
 * Signature: (Ljava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_com_houbin_jni_Hello_native_1say_1hello
  (JNIEnv *, jclass, jstring);

#ifdef __cplusplus
}
#endif
#endif
```
至此，java调用方代码工作完成。

## c++实现so

### 实现java生成头文件中所需的接口
``` ```
[root@pc jni]# cat hello.cc
#include <stdio.h>
#include "com_houbin_jni_Hello.h"

JNIEXPORT void JNICALL Java_com_houbin_jni_Hello_native_1say_1hello
  (JNIEnv *env, jclass clz, jstring j_name)
{
    const char *name = NULL;
    if (j_name)
    {
        name = env->GetStringUTFChars(j_name, NULL);
        if (!name)
        {
            return;
        }
    }

    printf("come from c, name is %s\n", name);
    return;
}
```

比较简单，没有做异常的处理，请见谅。

### 编译hello.cc文件为libhello.so
``` powershell
[root@pc jni]# g++ -fPIC  -D_REENTRANT -I/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.95.x86_64/include/ -I/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.95.x86_64/include/linux/ -c hello.cc
[root@pc jni]# g++ -shared hello.o -o libhello.so
[root@pc jni]# ll
total 32
drwxr-xr-x 3 root root 4096 Apr  4 09:25 com
-rw-r--r-- 1 root root  477 Apr  4 09:26 com_houbin_jni_Hello.h
-rw-r--r-- 1 root root  400 Apr  4 09:30 hello.cc
-rw-r--r-- 1 root root  587 Apr  4 09:25 Hello.java
-rw-r--r-- 1 root root 2584 Apr  4 09:42 hello.o
-rwxr-xr-x 1 root root 6720 Apr  4 09:43 libhello.so
```
将libhello.so拷贝到/usr/lib/等待使用。

至此，被调用方so也已经准备完毕。

## 测试
``` ```
[root@pc jni]# java com.houbin.jni.Hello
/root/src/StorageManage/:/usr/local/lib:/usr/local/hadoop/lib/native::/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib
come from c, name is 12345
```

这里只是一个简单的技术验证程序，生产代码要注意对异常的处理。
